Clean Code
07/08/2025

Reference:
https://github.com/Gatjuat-Wicteat-Riek/clean-code-book/blob/master/Clean%20Code%20(%20PDFDrive.com%20).pdf


Medium Digest
How to Write Clean Code, Actually..
https://medium.com/@brandt.a.derrick/how-to-write-clean-code-actually-5205963ec524


Chp01.	Clean Code
	code easy to read
8.	broken windows


Chp02.	Meaningful Names
	Indent - naming
21	Conventions
24	DISAGREE	Interface vs. Implementation
25	mental map = GOOD

class	noun
method	verb

26	cute
	pick one	Consistency
30	precise


Chp03.	Functions
34	small	4x lines
36	one thing	Single Responsibility
39	small	easier to name
40	Time!
	Consistent
	func args != IoC	Unit Test
42	args replaced by class field
43	func objects
	Intent
48	DRY


Chp04.	Comments
54	no comments - code	type hints
	self-describe code	unit tests	self-documenting
55	Intent			in code
56	Why = OK
60	Intent	what does the author mean?
63	Mandate	Yes - agree
64	Noise	Yes


Chp05.	Formatting
summary - like Chp1 - when code easy to read 
it's easy to understand, modify, fix, debug

76	simple rules - format
	team agree rules	automate
77	small files
	newspaper article 	separate
78	thoughts		blank lines
80	vertical distance	stop hopping around files
81	instance vars		at top contradicts newspaper metaphor
82	caller above callee
84	function call dependencies downward
85	80 chars wide		Python
88	w/o indentation		unreadable
90	team rules		agree on formatting style = consistent


Chp06.	Objects and Data Structures
93	private variables	don't want anyone to depend on them
	hide implementation
Global variables not mentioned
Global variables
make it difficult to track state changes
introduce hidden dependencies
can cause unexpected side effects	esp. larger / multithreaded apps

Global variables
discouraged due to maintainability and reproducibility concerns
better = config files, classes, parameters

94	interface [methods] enforce access policy
	hiding implementation = 	about abstractions
					layer of functions btwn variables
94	abstract interfaces that allows its users to manipulate essence of the
	data without having to know its implementation

95	do not expose details of data
95	Objects			hide data behind abstractions + expose functions on data
	Data structures		expose their data + no functions

97	Procedural code		Data structures		easy to add functions w/o change data structure
	Object Orientated	Classes			add new classes w/o change existing functions
	Usually want to add new functions rather than new data types

97	Law of Demeter
	module should not know about the innards of the objects it manipulates
However	internal structure	get accessor useful for unit tests

99	Hybrid			half object and half data structure
100	DTO			Data Transfer Objects
	useful when communicate w/ databases, messages from sockets
	move data efficiently between the layers

101	Active Record		special DTO but have navigational methods
101	Objects			expose behavior + hide data
	Data structures		expose data + no behavior
	Add new data types	prefer objects
	Add new behaviors	prefer data types and procedures


Chp07.	Error Handling
103	too much error handling	obscures logic	WRONG
104	better to throw an exception than to return an error code
105	exceptions define a scope within your program
106	narrow the type of exception to match type actually thrown
	checked exceptions not relevant for Python

107	context	create informative error messages pass with exceptions
	DO NOT log.error("something went wrong")

108	multiple exceptions caught here but Python can catch tuple of exceptions
	(TypeError, ValueError)
109	wrap third party API makes it easier to mock out third-party calls in UTs
110	No null -> empty object - used in games programming
112	Assertions - don't agree with this as modern way is to offload to UTs


Chp08.	Boundaries
SUMMARY	already knew a lot about this chapter i.e. Adaptor pattern and seams
	however don't think these concepts only apply to 3rd party S/W use for everything!!

114	Power = flexibility = liability	passing concrete types all around
115	Why?	liberally pass around the system = lot of places to fix when interface change
	Instead Map interface at the boundary = hidden
	Code that is easier to understand and hard to misuse
SCOTT Meyers
Interface	should be easy to use hard to misuse

115	Boundary interface keep inside class	also easier to UT [stub - black box]

116	Learning tests = I think of these as system tests	V/ important
	write [system] tests to explore understanding of [3rd party] code	ALL code!

118	Encapsulate - repeat idea of 3rd party code in class = black box = boundary interface
	learning tests = experiments that helped increase understanding

119	Code not exist = Adaptor pattern = write code to your interface
	integrate w/ 3rd party once API ready
	Code against your interface and "adapt" once destination implemented

SEAMS	thin interfaces that separate concerns	NOT tightly couple code
	good design to have seams in code - not just for 3rd party but everywhere
	makes code integration easier - minimize conflicts in code review / merge

120	Boundaries = Change
	Only thing in S/W that changes is change

Good S/W design accommodate change W/O huge rework
Depend on something you control - not something you don't = it will control you


Chp09.	Unit Tests
V/ familiar w/ TDD
121	last team I worked on still write throw away code as "tests"
122	3x laws of TDD
	TDD strange first time you do = write test for code that does not exist
123	test + prod code written together
123	Interesting - dirtier the tests the harder they are to change = liability
	maintain tests = expensive = don't maintain = increased bug count = less refactoring
STORY	BFG legacy tests rot never run = don't get value of writing them
124	Test code IMPORTANT as Prod code
	UTs keep code maintainable	otherwise code changes = maybe bug
ESP	important w/ Python		brittle language	UTs = code w/o fear
123	clean tests = reability
127	Build-Operate-Check	now	Arrange Act Assert	AAA
	Testing language	APIs that wrap Prod code called by Test code
127	Dual standard
130	What you might not do in Prod code OK for Test code
130 	One Assert - not so relevant in Python as can have single assert but parametrize
130	ditto Template Method - not so relevant in Python for same reason
131	However Single Concept per Test	DEFINITELY
131	bottom hints towards BDD	given when then		w/o saying BDD
132	minimize the no. asserts per concept	test one concept per test fn
132	FIRST	Fast, Independent, Repeatable, Self-Validating, Timely
133	Clean tests preserve maintainability of Prod code
	if you let tests rot then prod code rots	Keep tests clean


Chp10.	Classes
SOLID	Principle			S, O, D
136	Newspaper article repeat	Public then private variables
136	Classes = small
	Functions measure		no. lines
	Classes   measure		no. responsibilities
138	SRP Single Responsiblity Principle
	one reason to change only
GOD class = too many responsibilities
139	No time for refactoring
	move on to the next problem rather than refactoring09:56 09/09/2025
140	wade thru code!
140	Cohesion
	more variables a method manipulates the more cohesive that method is to is class
GOAL	highly cohesive loosely couple classes
141	When classes lose cohesion split them up	
EXAMPLE
147	Organize classes to reduce risk of change
	Open Closed principle
	opening a class introduces risk
	any modifications to the class can potentially break other code in the class
148	Example of O/C principle	no other code will break from change
149	incorporate new features by extending system NOT modify existing code
149	Isolate change
	Depend on abstractions not [concrete] implementations
	client depending on concrete details is at risk when those details change
150	lack of coupling means elements are better isolated from change
	DIP	Dependency Inversion [Injection?] principle
	classes should depend on abstractions not concrete details
IoC	Inversion of Control


Chp11.	Systems
SUMMARY	a lot of this chapter NOT relevant as is Java
	Spring, AspectJ, JBoss etc.
154	abstraction + modularity = individual components
	stay clean at higher levels of abstraction = the system level
	software systems separate startup process
	application objects constructed
	dependencies "wired" together
	runtime logic takes over after startup
VIOLATION	Lazy initialization example

155		break Single Responsibility rule
	global setup strategy is scattered across the application
	little modularity + significant duplication
	modularize process separately from runtime logic
	consistent strategy for resolving major dependencies

MAIN	build objects then pass them to application
me	eliminate CPU cycles to always check for null

156	Abstract Factory GoF
	construction separate from the application code

157	D.I.	IoC	dependency management
IMPORTANT	help break coupling btwn objects = better U/T
Do NOT do	A() { b = new B(); }
special-purpose container = IoC Contaner	Does Python have??

158	TDD	
	refactoring clean code produced make this work at code level
S/W systems architecture can grow incrementally if proper separation of concerns

160	EXAMPLE heavy coupling
AOP	Aspect-Orientated Programming
	general purpose approach to restoring modularity for cross-cutting concerns
aspects	modular constructs
161	Java proxies	NOT relevant
163	DDD	POJOs	domain objects
Cross-cutting concerns
persistence, transactions, security, caching, failover	[AOP] FRAMEWORKs
 
166	Test Drive
write app domain logic POJOs decoupled from architecture concerns at code level
= test drive architecture 
168	agility provided by modularized concerns allow to make optimal
	JIT decisions based on most recent knowledge
168	standards make it easier to reuse ideas and components
168	DSL minimizes comms gap btwn domain concept and code that implements it
169	DSL allow developer to reveal intent of code at right level of abstraction
169	when domain logic obscured then quality suffers	bugs easier to hide 


Chp12.	Emergence
172	4x simple rules
#1	runs all the tests
#2	contains no duplication
#3	expresses the INTENT of the programmer
#4	minimizes number of classes + methods

172	TESTS
#1	system test that cannot be verified should never be deployed
	tests run continuously impacts goals low coupling + high cohesion
	tests lead to better design
172	REFACTOR
#2	having tests eliminates fear that cleaning up the code will break it!
173	DUPLICATION
	DRY = no duplication
174	Template Method design pattern = remove higher-level duplication
175	EXPRESSIVE
#3	code should clearly express the intent of its author
	clearer the author can make the code the less time others understand it
	standard pattern names
	well written unit tests = expressive	documentation by example
176	get code working and move on	make code easy for next person
#4	MINIMAL
	keep class + function count low but more IMP to have tests, no dup + express
Simple design encourage developers to adhere to good principles and patterns


Chp13.	Concurrency
Very theoretical chp - not many examples but any code samples not relevant as is Java
178	Why?
Concurrency is a decoupling strategy
decouple what gets done from when it gets done
Decoupling what from when can dramatically improve both the throughput and structures of an application
Structure not the only motive for concurrency:
Some systems have response time and throughput constraints that require hand-coded concurrent solutions

179	Myths
Concurrency always improves performance
Design does not change when writing concurrent programs
- decouple what from when has huge effect on structure of system
Concurrency incurs some overhead
Correct concurrency is complex
Concurrency bugs arenâ€™t usually repeatable
Concurrency often requires a fundamental change in design strategy

180 	Challenges
code = 3x paths

181	Defense principles
SRP	concurrent code should be separated from the rest of the code
Recommendation: Keep your concurrency-related code separate from other code

Limit scope of data
protect critical section in code that uses shared object
Recommendation: Take data encapsulation to heart; severely limit the access of any data that may be shared

Copies of data
CSP	Communicating Sequential Processes
avoid sharing data inf the first place	copy objects and treat them as read-only

182	Threads independent
each thread exists independently sharing no data with any other thread
Recommendation: Attempt to partition data into independent subsets than can be
operated on by independent threads, possibly in different processors

Library	Thread-Safe collections		Python
queue
collections deque
list, dict, set
Locks
threading.Lock()
threading.RLock()			Reentrant lock

183
Reentrant lock		lock aquired in one method and released in another
Semaphore		implementation of classic semaphore: lock with a count
CountDownLatch		lock waits for no. events before releasing all threads
Recommendation: Review the classes available to you.

Execution Models	DEFINITIONS
Bound resources		resources of fixed size / number in concurrent environment
Mutual exclusion	only one thread can access shared data / resource at a time
Starvation		one thread prohibited from proceeding excessive long time
Deadlock		two or more threads wait for each other to finish
Livelock		threads in lockstep - each trying to do work but find another "in the way"

184
Execution Models	EXAMPLES
Producer-Consumer	queue = bound resource btwn producers + consumers
Reader-Writers		throughput = issue can cause starvation
Dining Philosophers	philosophers = threads and forks = resources
			processes compete for resources: deadlock, livelock, throughput, efficiency degradataion
185
Recommendation: Learn these basic algorithms and understand their solutions
Recommendation: Avoid using more than one method on a shared object

Critical sections must be guarded via locks = use as few critical sections as possible
Recommendation: Keep your synchronized sections as small as possible

186	Shutdown
Recommendation: Think about shut-down early and get it working early
186	Testing
Recommendation: Write tests that have the potential to expose problems and then run them frequently
187
Treat spurious failures as candidate threading issues	do not ignore system failures as one-offs
Get your nonthreaded code working first			do not change nonthreading + threading bugs at the same time
Make your threaded code pluggable			make thread-based code esp. pluggable = various configurations
188
Make your threaded code tunable				allow no. threads = easily tuned
Run with more threads than processors			encourage task swap via more threads than processors
Run on different platforms				run threaded code on all target platforms early + often
Instrument your code to try and force failures		hand-coded vs. automated

189	Hand-coded
divide system non-threading and classes that control threading = easier to instrument the code
189	Automated	frameworks	NOT relevant here as = Java
Recommendation: Use jiggling strategies to ferret out errors		Overkill for us??

190	Conclusion
SRP	break system into classes that separate thread-aware code from thread-ignorant code
thread-aware code should be small and focused
Find regions of code that need to be locked and lock them
Avoid calling one locked seciton from another	= deadlock
Keep shared objects and sharing as narrow as possible
Run thread-based code as long as possible before deploy to production


Chp14.	Successive Refinement
Very long chapter!
Important topic but felt should have used a much smaller + focused code sample
that could target successive refinement better - too much code in this chapter

200	How Did I do This?
Programming is a craft more than it is a science
To write clean code, you must first write dirty code and then clean it
this is a matter of successive refinement

201	Repeat
Jr programmers = get program working - once "working" move on to next task
leaving the "working" program in whatever state they finally got it to work

213	Incrementalist	TDD
Keep system running at all times
Achieve with suite of automated tests	verifies behavior of system unchanged
e.g.
ArgumentMarshaler
each change kept the system working
Indirectly he is saying "Make lots of changes iteratively"

214
Incrementalism demanded that I get this working quickly before making any other changes

215	TDD #2
When a test broke I made sure to get it passing again before continuing with the change

231	List = more flexible for additional args input
233	Refactoring = solving a Rubik's cube
Lots of little steps required to achieve a large goal
Each step enables that
TDD style = lots of small iterations = refactoring [with confidence]

250	Refactoring
Must of good software design = partitioning - create places to put different kinds of code
Separation of concerns makes code simpler to understand and maintain

CONCLUSION
Code that works is often badly broken
Programmers who satisfy themselves with merely working code are behaving unprofessionally
Nothing more profound and long-term degrading effect upon a development project than bad code

As code rots the modules insinuate themselves into each other creating lots of hidden and tangled dependencies.  Finding and breaking old dependencies is a long and arduous task
So the solution is to continuously keep your code as clean and simple as it can be
Never let the rot get started


Chp15.	JUnit Internals
Chp not relevant - JUnit Internals - seems to follow on previous chapter of refactoring

257	Boy Scout Rule
Leave the code cleaner than we found it

258	Example of splitting large function into 2x functions
259	Hidden temporal coupling
Function that depends on a function [that depends on a function...]

262	Refactoring = remove functions
265
Functions are topologically sorted so that the definition of each function appears just after it is used
Often one refactoring leaves to another that leads to the undoing of the first
Refactoring is an iterative process full of trial and error

CONCLUSION	Boy Scout Rule
Left module cleaner than we found it
No module is immune from improvement
Each of us has the responsibility to leave the code a little better than we found it


Chp16.	Refactoring
268	Test coverage	IMPORTANT
269	Boundary error	out-by-one
270	docs		IMPORTANT
271	enum		better
272	dead comments	remove
273	abstract factory
Bad idea for base classes to know about derivatives
274	other GOT design patterns
275	DRY examples
276	strange point	RE: final [sealed] if no class inherits then is correct
277	weird		Why duplicate Day if in Calendar	DRY
278	FEATURE ENVY	Not heard of that
Constant refactoring	esp. out into own class
279	EXPLAINING TEMPORARY VARIABLES	not heard of that
280	Intent
It seems to me that the intent of the method is captured nicely by
DayDate date = oldDate.plusDays(5);
281	YAGNI
only users of this function were tests just modified = deleted the tests
283	summary of changing
DRY eliminate duplicaiton
284 	Boy Scout rule


Chp17.	Smells and Heuristics
COMMENTS
286	
Inappropriate Info	but people store this in README.md
Obsolete Comment
Redundant Comment	comments say things code cannot say	why NOT what

287
Poorly Written Comment	be brief
Commented-Out Code	dead code = rot	Delete It!!

ENVIRONMENT
287
Build Requires More Than One Step	checkout + build system single command
Tests Require  More Than One Step	pytest

FUNCTIONS
288
Too Many Arguments	more than 3 = put in class
Output Arguments	Disagree -> easier to unit test	unless use properties everywhere
Flag Arguments		Disagree	dry-run
Dead Function		dead code = delete

GENERAL
288
Multiple Languages in One Source File	N/A
Obvious Behavior Is Unimplemented	can't depend on intuition about function names

289
Incorrect Behavior at the Boundaries	write test for every boundary condition
Overridden Safeties			don't ignore warnings + failing tests
Duplication		DRY		abstraction
			if/else		polymorphism
290
Template Method OR Strategy		nice if he explained w/ an example!
Code at Wrong Level of Abstraction	don't mix higher + lower level concepts

291
Base Classes Depending on Their Derivatives
Too Much Information			well-defined interface = low coupling
292					hide your data
					keep interfaces tight and small
292
Dead code				delete
Vertical Separation			limit vertical distance for variables + functions
					scan down to first usage
Inconsistency				principle of least surprise
					consistency = code easier to read + modify

293
Clutter		similar to dead code	unused code = delete
Artificial Coupling			couple 2x modules serves no direct purpose
Feature Envy				method envies the scope of another object

294					exposes internals of one class to another
Selector Arguments			dangling boolean - what does it mean?

295
Obscure Intent				make intent of code visible
Misplace Responsibility			principle of least surprise - put where reader expects

296
Inappropriate Static			don't write static functions that could be polymorphic
Use Explanatory Variables		opaque module more transparent = break up calculations

297
Function Names Should Say What They Do	ensure you can tell from function call what func does
Understand the Algorithm		ensure you understand obvious how function works

298
Make Logical Dependencies		module it depends on should explicitly ask for all data

299
Prefer Polymorphism to If/Else or Switch/Case	every switch statement should be suspect
Follow Standard Conventions		coding standard based on industry norms!

300
Replace Magic Numbers with Named Constants

301
Be Precise				ambiguities + impression in code = disagreements + laziness
Structure over Convention		structures force compliance e.g. base class enforcement
Encapsulate Conditionals		extract functions that explain intent of conditional

302
Avoid Negative Conditionals		conditionals should be expressed as positives
Functions Should Do One Thing		SRP - convert large fn into many smaller func
Hidden Temporal Couplings		expose temporal coupling = create bucket brigade

303
Don't Be Arbitrary			consistent structure = others preserve the convention

304
Encapsulate Boundary Conditions		put boundary conditions in one place
Functions Should Descend Only One Level of Abstraction	don't mix levels of abstraction

305
separating levels of abstraction = one of the most important functions of refactoring

306
Keep Configurable Data at High Levels	config constants at high level are easy to change
Avoid Transitive Navigation		Law of Demeter	"Writing Shy Code"
					want immediate collaborators to offer all services we need

JAVA
307
Avoid Long Import Lists by Using Wildcards	Python says don't do this
Don't Inherit Constants
Constants vs. Enums			308


NAMES
309
Choose Descriptive Names		names in S/W = 90% S/W readable
					names overload the structure of code w/ description
311
Choose Names at the Appropriate Level of Abstraction
choose names that reflect level of abstraction of class or function working with

Use Standard Nomenclature Where Possible	e.g. toString()
						ubiquitous language

312
Unambiguous Names			explanatory values outweighs the length
Use Long Names for Long Scopes		short var names short scopes big scopes = longer names
Avoid Encodings				e.g. no Hungarian Notation

313
Names Should Describe Side-Effects	create or return


TESTS
313
Insufficient Tests			test suite test everything that could possible break
Use a Coverage Tool			find modules insufficiently tested
Don't Skip Trivial Tests		documentary value = higher than cost to produce
An Ignored Tests is a Question about an Ambiguity

314
Test Boundary Conditions
Exhaustively Test Near Bugs		bugs tend to congregate
Patterns of Failure Are Revealing	find patterns in the way test cases fail
Test Coverage Patterns Can Be Revealing
Tests Should be Fast			do what you must to keep tests fast


CONCLUSION
Clean code is not written by following a set of rules
Professionalism and craftsmanship come from values that drive disciplines
