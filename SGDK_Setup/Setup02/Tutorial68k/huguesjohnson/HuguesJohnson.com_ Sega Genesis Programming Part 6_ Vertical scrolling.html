<html>

<head>
<title>HuguesJohnson.com: Sega Genesis Programming Part 6: Vertical scrolling</title>
<!-- begin head includes -->

<!-- 2020-05-20 11:40:55 -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Hugues Johnson">
<base target="_top">
<link rel="icon" href="https://huguesjohnson.com/favicon.ico">
<link href="https://www.huguesjohnson.com/rss/rss.xml" rel="alternate" title="RSS feed for all updates" type="application/rss+xml" />
<!-- Apple icons -->
<link rel="apple-touch-icon" href="https://huguesjohnson.com/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="57x57" href="https://huguesjohnson.com/images/apple-touch-icon_57x57.png">
<link rel="apple-touch-icon" sizes="76x76" href="https://huguesjohnson.com/images/apple-touch-icon_76x76.png">
<link rel="apple-touch-icon" sizes="120x120" href="https://huguesjohnson.com/images/apple-touch-icon_120x120.png">
<link rel="apple-touch-icon" sizes="152x152" href="https://huguesjohnson.com/images/apple-touch-icon_152x152.png">
<link rel="apple-touch-icon" sizes="167x167" href="https://huguesjohnson.com/images/apple-touch-icon_167x167.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://huguesjohnson.com/images/apple-touch-icon_180x180.png">
<!-- fonts -->
<link href="https://fonts.googleapis.com/css?family=Audiowide|Ubuntu" rel="stylesheet">
<!-- Bootstrap core CSS -->
<script src="https://huguesjohnson.com/bootstrap/450/jquery-3.5.1.slim.min.js"></script>
<script src="https://huguesjohnson.com/bootstrap/450/popper.min.js"></script>
<script src="https://huguesjohnson.com/bootstrap/450/js/bootstrap.min.js"></script>
<link href="https://huguesjohnson.com/bootstrap/450/css/bootstrap.min.css" rel="stylesheet">
<!-- Bootstrap overrides -->
<link href="https://huguesjohnson.com/bootstrap/450/bootstrap-override-2020-05-20.css" rel="stylesheet">
<!-- end head includes -->
</head>

<body>

<!-- begin navbar -->
<nav class="navbar navbar-expand-md navbar-light p-0 sticky-top navbar-custom">
    <a class="navbar-brand navbarurl" href="https://huguesjohnson.com/">HuguesJohnson.com</a>
  <button class="navbar-toggler mr-3" type="button" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse flex-grow-1" id="navbarContent">
        <ul class="navbar-nav mr-auto">
		  <li class="nav-item dropdown">
		    <a class="nav-link dropdown-toggle" href="#" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Software</a>
		    <div class="dropdown-menu" aria-labelledby="dropdown01">
		      <a class="dropdown-item" href="https://huguesjohnson.com/rc89/">Retail Clerk '89</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/narpassword/">NARPassword</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/debigulator.html">Debigulator</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/programming/">Programming Articles</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/archive.html">Archive</a>
		    </div>
		  </li>
		  <li class="nav-item dropdown">
		    <a class="nav-link dropdown-toggle" href="#" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Retro Gaming</a>
		    <div class="dropdown-menu" aria-labelledby="dropdown01">
		      <a class="dropdown-item" href="https://huguesjohnson.com/features/">Features</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/scans/">Scans</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/guides/">Guides</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/game-hunter/">Game Hunter</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/collecting-apps.html">Collecting Apps</a>
		    </div>
		  </li>
		  <li class="nav-item dropdown">
		    <a class="nav-link dropdown-toggle" href="#" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Game Hacking</a>
		    <div class="dropdown-menu" aria-labelledby="dropdown01">
		      <a class="dropdown-item" href="https://huguesjohnson.com/aridia/">Aridia</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/eisfrei/">Eisfrei</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/hapsby.html">Hapsby</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/power-ups/">Power-Ups</a>
		      <a class="dropdown-item" href="https://huguesjohnson.com/falcom.html">Falcom Translations</a>
		    </div>
		  </li>
        </ul>
        <ul class="navbar-nav">
			<li class="nav-item dropdown">
            	<a class="nav-link dropdown-toggle" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Connect</a>
                    <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
                        <a class="dropdown-item" href="https://huguesjohnson.com/rss/rss.xml"><img border="0" src="https://huguesjohnson.com/images/feed-icon-16x16.gif" alt="Site RSS">&nbsp;Subscribe</a>
                        <a rel="me" class="dropdown-item" href="https://www.linkedin.com/in/huguesjohnson"><img border="0" src="https://huguesjohnson.com/images/l-16x16.gif" alt="LinkedIn profile">&nbsp;LinkedIn</a>
                        <a rel="me" class="dropdown-item" href="https://github.com/huguesjohnson"><img border="0" src="https://huguesjohnson.com/images/github-16x16.gif">&nbsp;GitHub</a>
                        <a class="dropdown-item" href="https://huguesjohnson.com/podcasts.html"><img border="0" src="https://huguesjohnson.com/images/podcast-16.png">&nbsp;Podcasts</a>
                        <a class="dropdown-item" href="https://huguesjohnson.com/links.html"><img border="0" src="https://huguesjohnson.com/images/link-16.png">&nbsp;Other Links</a>
                        <a class="dropdown-item" href="https://huguesjohnson.com/contact.html"><img border="0" src="https://huguesjohnson.com/images/mail-16x16.png">&nbsp;Contact</a>
                        <a class="dropdown-item" href="https://huguesjohnson.com/bio.html"><img border="0" src="https://huguesjohnson.com/images/q16x16.png">&nbsp;About Me</a>
                        <a class="dropdown-item" href="https://meloniejohnson.com/"><img border="0" src="https://huguesjohnson.com/images/mj16x16.png">&nbsp;Melonie Johnson</a></a>
                    </div>
                </li>
            </ul>
    </div>
</nav>
<!-- end navbar -->

<div class="jumbotron jumbotron-fluid jumbotron-custom" style="background-image: url(https://huguesjohnson.com/images/banner/md.png)">
  <div class="container">
		<h1 class="blog-title"><img src="logo.png" alt="Sega Genesis Programming Part 6: Vertical Scrolling" class="img-fluid" /></h1>
  </div>
</div>

<!-- start breadcrumb -->
<nav aria-label="breadcrumb">
  <ol class="breadcrumb breadcrumb-custom">
    <li class="breadcrumb-item"><a href="https://huguesjohnson.com/">home</a></li>
    <li class="breadcrumb-item active" aria-current="page"><a href="https://huguesjohnson.com/software-index.html">software</a></li>
    <li class="breadcrumb-item active" aria-current="page"><a href="https://huguesjohnson.com/programming/">programming articles</a></li>
    <li class="breadcrumb-item active" aria-current="page">sega genesis programming part 6: vertical scrolling</li>
  </ol>
</nav>
<!-- end breadcrumb -->

<div class="container-fluid">
	
	<div class="row">
		<div class="col">
			<a class="float-left" href="https://huguesjohnson.com/programming/genesis/collision-detection/">&lt;- Part 5: Collision Detection</a>
		</div>
		<div class="col">
			&nbsp;
			<a class="float-right" href="https://huguesjohnson.com/programming/genesis/npcs/">Part 7: NPC Sprites -&gt;</a>
		</div>
	</div>
	<br>

<p class="lead">Progress Report</p>

<p>When I set off on this crazy Genesis programming idea I decided to be realistic about the timeline. I figured if I could sneak in about 1 feature a month that would be acceptable. In the past I had dumb goals like &quot;<i>create an entire RPG roughly the size of Phantasy Star II, III, and IV combined before I turn 30</i>&quot;, which I set for myself around the time I turned 29. 10 years later I had a similar unrealistic goal only then it was for something roughly the size of Final Fantasy I-VIII combined before I turned 40. Now it's &quot;<i>let's see what I can get working and if it turns into a game that's great otherwise at least I'm doing something mentally stimulating</i>&quot;. At my current pace I'm a little behind the one feature a month goal which isn't awesome but I'm OK with that. The nice thing about working on a Sega Genesis game in 2016 is that I don't have to rush to make Xmas season of 1994. I can't imagine the pressure on teams working on 16-bit games then. The Saturn and PlayStation were on their way so you knew if you missed Xmas 1994 your game was dead. If I miss Xmas 2016, whatever.</p>

<p>My latest very small addition is vertical scrolling. As far as I can tell, vertical scrolling and horizontal scrolling don't work exactly the same. Although it's more likely I just don't completely understand it all yet.</p>

<p>Well, that wasn't my only accomplishment, I also wrote another small tool. One unexpected consequence of this idea is spending time creating utilities to generate code. A <a href="https://huguesjohnson.com/programming/genesis/animated-sprites/">couple articles ago I created a tile &amp; palette editor in C#</a>, now I need something to make collision map data creation easier.</p>

<p>In the <a href="https://huguesjohnson.com/programming/genesis/collision-detection/">last article</a> I tried storing collision data for a map in pairs of longs each representing 32 tiles, combined for one row (512px). This worked pretty well so I 'm going to build off it.</p>


<p>Instead of working with 0s and 1s I decided to write a program that could read a bitmap and generate the collision data based on it, where a white pixel = open space and any other color = blocked space. So now my collision data looks like a screen from Adventure on Atari 2600 which is a bonus. Here's the 64x64 (512x512 collision points) map for my work-in-progress demo, obviously scaled-up.</p>

<p><img src="map.png" alt="Collision map" class="img-fluid d-block mx-auto"/></p>

<p>I know many programmer-types who think mixing languages on a project is the worst thing ever. I was one of them at some point in my career. Now I've come around to <i>&quot;use the best tool for the job&quot;</i>. When I want to write client UIs I almost always use C# and WinForms, when I want to write a quick command-line tool I almost always use Java. I understand Python is probably a better choice for the latter but right now I can write Java a lot faster. Writing UIs in Java though should be considered a violation of the Geneva Convention. OK, OK, JavaFX is really easy to write UIs with, fine. The only problems are that it only runs on Windows (so long &quot;write once, run anywhere&quot;) and I'm 99% sure Oracle is going to scrap it soon.</p>

<p>Anyway, here's the Java code that converts a bitmap to collision data:</p>

<div class="well">
<p>//code to read bmp pixels is from: <a href="https://stackoverflow.com/questions/17015340/how-to-read-a-bmp-file-identify-which-pixels-are-black-in-java">https://stackoverflow.com/questions/17015340/how-to-read-a-bmp-file-identify-which-pixels-are-black-in-java</a></p>
<p>//everything else is original</p>
<p>public class JBMP2ASM{</p>
<p>&nbsp;private final static String newLine=System.lineSeparator();</p>
<p>&nbsp;//arg[0]=source file (bitmap)</p>
<p>&nbsp;//arg[1]=output file (text)</p>
<p>&nbsp;//if the width of the image isn't a multiple of 32 then bad times</p>
<p>&nbsp;public static void main(String[] args){</p>
<p>&nbsp;&nbsp;FileWriter writer=null;</p>
<p>&nbsp;&nbsp;try{</p>
<p>&nbsp;&nbsp;&nbsp;if(args.length!=2){throw(new Exception("Expecting two arguments: sourcefile outputfile"));}</p>
<p>&nbsp;&nbsp;&nbsp;String sourceFilePath=args[0];</p>
<p>&nbsp;&nbsp;&nbsp;String outputFilePath=args[1];</p>
<p>&nbsp;&nbsp;&nbsp;File sourceFile=new File(sourceFilePath);</p>
<p>&nbsp;&nbsp;&nbsp;BufferedImage image = ImageIO.read(sourceFile);</p>
<p>&nbsp;&nbsp;&nbsp;int width=image.getWidth();</p>
<p>&nbsp;&nbsp;&nbsp;if(width%32!=0){throw(new Exception("Image width must be a multiple of 32"));}</p>
<p>&nbsp;&nbsp;&nbsp;int height=image.getHeight();</p>
<p>&nbsp;&nbsp;&nbsp;writer=new FileWriter(outputFilePath);</p>
<p>&nbsp;&nbsp;&nbsp;for(int y=0;y&lt;height;y++){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;long longValue=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;int power=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;for(int x=0;x&lt;width;x++){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int color=image.getRGB(x,y);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (color!=Color.WHITE.getRGB()) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longValue+=Math.pow(2,power);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(power==31){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer hexValue=new StringBuffer(Long.toHexString(longValue).toUpperCase());</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int pad=8-hexValue.length();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i<pad;i++){hexValue.insert(0,'0');}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexValue.insert(0,&quot;\tdc.l\t$&quot;);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(hexValue.toString());</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.write(newLine);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longValue=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;power=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;power++;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;System.out.println("Successfully wrote "+outputFilePath);</p>
<p>&nbsp;&nbsp;}catch(Exception x){</p>
<p>&nbsp;&nbsp;&nbsp;x.printStackTrace()</p>
<p>&nbsp;&nbsp;}finally{</p>
<p>&nbsp;&nbsp;&nbsp;try{if(writer!=null){writer.flush(); writer.close();}}catch(Exception x){ }</p>
<p>&nbsp;&nbsp;}</p>
<p>&nbsp;}</p>
<p>}</p>
</div>

<p>With that out of the way, let's get back to some beautiful assembly code.</p>

<br/>

<p class="lead">Vertical Scrolling</p>

<p>Assuming I have this right, and that's not exactly a safe assumption, updating the vertical scroll position is just a matter of incrementing a value. The most excruciatingly fun part of this was figuring out how to scroll both the A &amp; B planes at the same time. The Genesis allows planes to be scrolled independently, 25 years ago you might have engaged in nerdy debates with your friends about which systems had &quot;parallax scrolling&quot;. When writing to the vertical scroll RAM (VSRAM) a long value is passed. The upper word contains the vertical scroll value for the B planes and the lower word contains the vertical scroll value for the A planes. In this demo I'm scrolling both planes at the same time so the same value needs to be passed in both the high and low word. I burned quite a few hours trying to figure out why only the A plane was scrolling which I feel kinda dumb about now.</p>

<p>As usual, I'm creating a sub-routine and couple constants to handle scrolling:</p>

<div class="well">
<p>MEM_MAP_POSITION_X=$00FF0020 ; x position of the map</p>
<p>MEM_MAP_POSITION_Y=$00FF0022 ; y position of the map</p>
<p>MEM_FLAG_MAP_POSITION_CHANGED=$00FF0024 ; >0 if map position changed</p>
<p>VDP_VRAM_WRITE_HSCROLL=$7C000002</p>
<p>VDP_VRAM_WRITE_VSCROLL=$40000010</p>
<p>[...]</p>
<p>SetMapScroll:
<p> ; set vertical scroll</p>
<p> ; -------------------------------------------------------------</p>
<p> ; when writing to VSRAM the upper word is the scroll B value</p>
<p> ; and the lower word is the scroll A value</p>
<p> ; in this demo they are scrolling at the same time so the</p>
<p> ; MEM_MAP_POSITION_Y value needs to set for both words</p>
<p> ; -------------------------------------------------------------</p>
<p> move.w MEM_MAP_POSITION_Y,d0 ; copy Y map position to d0 lower word</p>
<p> swap d0 ; move Y map position to upper word</p>
<p> move.w MEM_MAP_POSITION_Y,d0 ; copy Y map position to d0 lower word</p>
<p> ; the Y map position is now in both words of d0</p>
<p> move.l #VDP_VRAM_WRITE_VSCROLL,VDP_CONTROL ; setup write to vscroll</p>
<p> move.l d0,VDP_DATA ; copy y position to vscroll</p> 
<p> move.w #$0000,(MEM_FLAG_MAP_POSITION_CHANGED) ; reset flag to false</p>
<p>EndSetMapScroll:</p>
<p> rts</p>
</div>

<p>Yeah, I'm updating the horizontal scroll here too but it's never changed anywhere in the rest of the code. The idea here is there's a flag that's set when the map position has changed which will trigger a call to SetMapScroll. Calling it too frequently definitely slows the entire game down (trust me). That means the main loop is modified a little. The new code is bolded:</p>

<div class="well">
<p>MainGameLoop:</p>
<p>&nbsp;bsr.w WaitVSync ; wait for vsync to complete</p>
<p>&nbsp;add.w #$0001,(MEM_DEBUG_MAINLOOP_COUNTER) ; debug code</p>
<p>&nbsp;bsr.w MovePlayer ; move the player sprite</p>
<p>&nbsp;; other game logic would go here</p>
<b><p>&nbsp;cmpi.w #$0000,(MEM_FLAG_MAP_POSITION_CHANGED) ; test for scrolling</p>
<p>&nbsp;beq.w MainGameLoopEnd ; not scrolling, exit</p>
<p>&nbsp;bsr.w SetMapScroll ; else scroll the map</p></b>
<p>MainGameLoopEnd:</p>
<p>&nbsp;bra.s MainGameLoop ; return to start of game loop</p>
</div>

<p>Since I'm in the mood to create constants, here are a few more that may or may not be used later on:</p>

<div class="well">
<p>; screen & plane sizes</p>
<p>DISPLAY_PIXELS_X=$0140 ; width of physical display</p>
<p>DISPLAY_PIXELS_Y=$00E0 ; height of physical display</p>
<p>SPRITE_PLANE_PIXELS_X=$0200 ; width of sprite virtual plane</p>
<p>SPRITE_PLANE_PIXELS_Y=$0200 ; height of sprite virtual plane</p>
<p>SPRITE_PLANE_OFFSET_TOP=$0080 ; sprite plane top to display top edge</p>
<p>SPRITE_PLANE_OFFSET_LEFT=$0080 ; sprite plane left to display left edge</p>
<p>SPRITE_PLANE_OFFSET_BOTTOM=$00A0 ; sprite plane bottom to display bottom edge</p>
<p>SPRITE_PLANE_OFFSET_RIGHT=$0040 ; sprite plane right to display right edge</p>
<p>VDP_PLANE_PIXELS_X=$0200 ; width of VDP plane</p>
<p>VDP_PLANE_PIXELS_Y=$0100 ; height of VDP plane</p>
</div>

<p>Now we just need a couple more constants that will be used to compute when to scroll. The idea here is that when the sprite is X pixels away from the edge then we need to scroll. These are the values that will be used:</p>

<div class="well">
<p>SPRITE_PLAYER_HEIGHT=$0020 ; how many pixels tall the player sprite is</p>
<p>SPRITE_PLAYER_WIDTH=$0010 ; how many pixels wide the player sprite is</p>
<p>PLAYER_SCROLL_BOUNDARY=$0040 ; base value</p>
<p>PLAYER_SCROLL_BOUNDARY_TOP=PLAYER_SCROLL_BOUNDARY</p>
<p>PLAYER_SCROLL_BOUNDARY_BOTTOM=PLAYER_SCROLL_BOUNDARY+SPRITE_PLAYER_HEIGHT</p>
<p>PLAYER_SCROLL_BOUNDARY_LEFT=PLAYER_SCROLL_BOUNDARY</p>
<p>PLAYER_SCROLL_BOUNDARY_RIGHT=PLAYER_SCROLL_BOUNDARY+SPRITE_PLAYER_WIDTH</p>
</div>

<p>Now it's time to add a little code to the MovePlayer method that checks if the player sprite is approaching the top or bottom edge of the display and, if so, sets off the chain of events to scroll vertically. The new code is again bolded:</p>

<div class="well">
<p>[...]</p>
<p>TestUpHeld:</p>
<p>&nbsp;move.b (MEM_CONTROL_HELD),d7 ; copy button held value to d7 for andi</p>
<p>&nbsp;andi.w #BUTTON_UP_PRESSED,d7 ; test if the up button is held</p>
<p>&nbsp;beq.s TestDownHeld ; branch if not</p>
<p>&nbsp;move.w #DIRECTION_UP,(MEM_PLAYER_SPRITE_DIRECTION) ; set direction</p>
<b><p>&nbsp;; test if map should scroll because the player is approaching the boundary</p>
<p>&nbsp;; top boundary is [current map y-position]</p>
<p>&nbsp;move.w (MEM_MAP_POSITION_Y),d7 ; move map y-position to d7</p>
<p>&nbsp;cmpi.w #$0000,d7 ; are we already scrolled to the top?</p>
<p>&nbsp;ble.w MovePlayerSprite ; if so stop testing for scroll</p>
<p>&nbsp;; at this point d7 contains the y value of the top boundary</p>
<p>&nbsp;add.w #SPRITE_PLANE_OFFSET_TOP,d7 ; adjust for sprite plane offset</p>
<p>&nbsp;sub.w (MEM_PLAYER_SPRITE_Y),d7 ; subtract sprite y</p>
<p>&nbsp;cmpi.w #PLAYER_SCROLL_BOUNDARY_TOP,d7 ; is sprite within scroll area?</p>
<p>&nbsp;; bcc used here because previous subtraction can lead to negative number</p>
<p>&nbsp;bcc.w MovePlayerSprite ; if not stop testing for scroll</p>
<p>&nbsp;sub.w #$0001,(MEM_MAP_POSITION_Y) ; decrement map y-position</p>
<p>&nbsp;move.w #$0001,(MEM_FLAG_MAP_POSITION_CHANGED) ; flag to reset the scroll</p>
<p>&nbsp;bra.w MovePlayerSprite ; move the player sprite</p></b>
<p>TestDownHeld:</p>
<p>&nbsp;move.b (MEM_CONTROL_HELD),d7 ; copy button held value to d7 for andi</p>
<p>&nbsp;andi.w #BUTTON_DOWN_PRESSED,d7 ; test if the down button is held</p>
<p>&nbsp;beq.s TestLeftHeld ; branch if not</p>
<p>&nbsp;move.w #DIRECTION_DOWN,(MEM_PLAYER_SPRITE_DIRECTION) ; set direction</p>
<b><p>&nbsp;; test if map should scroll because the player is approaching the boundary</p>
<p>&nbsp;; bottom boundary is [current map y-position]+[screen height]</p>
<p>&nbsp;move.w (MEM_MAP_POSITION_Y),d7 ; move map y-position to d7</p>
<p>&nbsp;add.w #DISPLAY_PIXELS_Y,d7 ; add the screen height</p>
<p>&nbsp;cmpi.w #VDP_PLANE_PIXELS_Y,d7 ; are we already scrolled to the bottom?</p>
<p>&nbsp;bge.w MovePlayerSprite ; if so stop testing for scroll</p>
<p>&nbsp;; at this point d7 contains the y value of the bottom boundary</p>
<p>&nbsp;add.w #SPRITE_PLANE_OFFSET_TOP,d7 ; adjust for sprite plane offset</p>
<p>&nbsp;sub.w (MEM_PLAYER_SPRITE_Y),d7 ; subtract sprite y</p>
<p>&nbsp;cmpi.w #PLAYER_SCROLL_BOUNDARY_BOTTOM,d7 ; is sprite within scroll area?</p>
<p>&nbsp;bge.w MovePlayerSprite ; if not stop testing for scroll</p>
<p>&nbsp;add.w #$0001,(MEM_MAP_POSITION_Y) ; increment map y-position</p>
<p>&nbsp;move.w #$0001,(MEM_FLAG_MAP_POSITION_CHANGED) ; flag to reset the scroll</p>
<p>&nbsp;bra.s MovePlayerSprite ; move the player sprite</p></b>
<p>TestLeftHeld:</p>
<p>[...]</p>
</div>

<p>This could probably be trimmed down a little bit. As noted in previous articles, I'm not too concerned about optimizing now except when there's an obvious performance issue.</p>

<p>Now when moving down the counter scrolls:</p>

<p><img src="down.png" alt="Moving down" class="img-fluid d-block mx-auto"/></p>

<p>And when moving up the counter scrolls back into place:</p>

<p><img src="up.png" alt="Moving up" class="img-fluid d-block mx-auto"/></p>

<p class="lead">Updating Collision Detection</p>

<p>The <a href="https://huguesjohnson.com/programming/genesis/collision-detection/">collision detection algorithm I patched together in the last article</a> is based on the sprite position against a map but didn't account for scrolling (for obvious reasons). There are barely any changes needed though, again they are bolded:</p>

<div class="well">
<p>TestSpriteCollision:</p>
<p>&nbsp;; a6 = SPRITE_ID</p>
<p>&nbsp;; a6 + 2 = SPRITE_X</p>
<p>&nbsp;; a6 + 4 = SPRITE_Y</p>
<p>&nbsp;; a6 + 6 = SPRITE_PATTERN_INDEX</p>
<p>&nbsp;; a6 + 8 = SPRITE_DIRECTION</p>
<p>&nbsp;; a6 + A = SPRITE_FRAME</p>
<p>&nbsp;; a6 + C = SPRITE_STEP_COUNTER</p>
<p>&nbsp;movea.l a6,a4 ; store address in a4 because it is manipulated</p>
<p>&nbsp;adda.l #$4,a4 ; move to a4+4 -> SPRITE_Y</p>
<p>&nbsp;move.w (a4),d6 ; copy the sprite's y-position to d6</p>
<p>&nbsp;add.w #$11,d6 ; sprites are 32px tall, test collision against lower half</p>
<p><b>&nbsp;add.w (MEM_MAP_POSITION_Y),d6 ; adjust for scroll</b></p>
<p>&nbsp;adda.l #$4,a4 ; move to a4+8 -> SPRITE_DIRECTION</p>
<p>&nbsp;move.w (a4),d7 ; store direction in a7</p>
<p>&nbsp;cmpi.w #DIRECTION_UP,d7 ; test if sprite is moving up</p>
<p>&nbsp;bne.s TestDownCollision ; branch if not</p>
<p>&nbsp;sub.w #$08,d6 ; sprite is moving up, test tile 1 up from sprite</p>
<p>TestDownCollision:</p>
<p>&nbsp;cmpi.w #DIRECTION_DOWN,d7 ; test if sprite is moving down</p>
<p>&nbsp;bne.s TestSpriteCollisionRoundToRow ; branch if not</p>
<p>&nbsp;add.w #$08,d6 ; sprite is moving down, test tile 1 down from sprite</p>
<p>TestSpriteCollisionRoundToRow:</p>
<p>&nbsp;andi.b #%11111000,d6 ; clear bits 0-2 to round to nearest power of 8</p>
<p>&nbsp;suba.l #$6,a4   ; move back to a4+6 -> SPRITE_X</p>
<p>&nbsp;cmpi.w #DIRECTION_RIGHT,d7 ; test if sprite is moving right</p>
<p>&nbsp;bne.s TestLeftCollision ; branch if not</p>
<p>&nbsp;move.w (a4),d7 ; d7 is no longer needed, copy sprite x to it</p>
<p><b>&nbsp;add.w (MEM_MAP_POSITION_X),d7 ; adjust for scroll</b></p>
<p>&nbsp;add.w #$08,d7 ; sprite is moving right, test tile 1 right from sprite</p>
<p>&nbsp;bra.s TestCollisionColumn ; sprite can't move both left & right</p>
<p>TestLeftCollision:</p>
<p>&nbsp;cmpi.w #DIRECTION_LEFT,d7 ; test if sprite is moving left</p>
<p>&nbsp;bne.s NoHCollision ; branch if not</p>
<p>&nbsp;move.w (a4),d7 ; d7 is no longer needed, copy sprite x to it</p>
<p><b>&nbsp;add.w (MEM_MAP_POSITION_X),d7 ; adjust for scroll</b></p>
<p>&nbsp;sub.w #$08,d7 ; sprite is moving left, test tile 1 left from sprite</p>
<p>&nbsp;bra.s TestCollisionColumn ; skip default copy of (a4) to d7</p>
<p>NoHCollision:</p>
<p>&nbsp;move.w (a4),d7 ; left & right flows store sprite x in d7</p>
<p>TestCollisionColumn:</p>
<p>&nbsp;cmpi.w #$0100,d7 ; is sprite on the left or right side of the screen?</p>
<p>&nbsp;blt.s TestMapCollision ; left side, go directly to collision test</p>
<p>&nbsp;add.w #$0004,d6 ; on the right side, use 2nd lword for the row</p>
<p>TestMapCollision:</p>
<p>&nbsp;move.w d6,MEM_COLLISION_TEST ; copy d6 to collision test location</p>
<p>&nbsp;lea  MapStoreCollision,a3 ; move address of map data to a3</p>
<p>&nbsp;adda.w (MEM_COLLISION_TEST),a3 ; move to row & col</p>
<p>&nbsp;move.l (a3),MEM_COLLISION_MAP_ROW ; copy row data to memory</p>
<p>&nbsp;move.w d7,d6 ; copy the sprite's x-position to d6</p>
<p>&nbsp;and.w #$00FF,d6 ; remove all bits over 255</p>
<p>&nbsp;divu.w #$08,d6 ; divide by 8 to get index in map data</p>
<p>&nbsp;; clear remainder from high word</p>
<p>&nbsp;; credit to <a href="https://www.easy68k.com/paulrsm/doc/trick68k.htm">https://www.easy68k.com/paulrsm/doc/trick68k.htm</a> for this trick</p>
<p>&nbsp;swap d6  ; swap upper and lower words</p>
<p>&nbsp;clr.w d6 ; clear the upper word</p>
<p>&nbsp;swap d6  ; swap back</p>
<p>&nbsp;move.w #$0000,(MEM_COLLISION_RESULT) ; clear result</p>
<p>&nbsp;move.l MEM_COLLISION_MAP_ROW,d7 ; move map data to d7</p>
<p>&nbsp;btst.l d6,d7 ; test for collision</p>
<p>&nbsp;beq.w ExitTestSpriteCollision ; no collision, exit</p>
<p>&nbsp;move.w #$FFFF,(MEM_COLLISION_RESULT) ; collision is true, set result</p>
<p>ExitTestSpriteCollision:</p>
<p>&nbsp;rts</p>
</div>


<p>That was pretty painless all around, so why did it take me almost 3 months to publish this? Simple, I decided the store looked a little dull. After several demos we have the same bland scenery, it was time to spruce things up...</p>

<p class="lead">New Scenery</p>

<p>If the setting is going to be a store in a 1989 mall I suppose it needs some merchandise and a storefront.</p>

<p>To keep things simple I'm only using 3 layers. <b>Scroll B Low</b> will be used for tiled background scenery, <b>Scroll A Low</b> will be used for solid ground-level scenery, and <b>Scroll A High</b> will be used for the store structure and other scenery the sprite can walk under.</p>

<p>Let's start with creating some merchandise for the store shelves. Since I'm not very artistic I created a simple 3-tile pattern that looks like a generic game box.</p>

<p><img src="tileset-shelves.png" alt="Tileset for shelves" class="img-fluid d-block mx-auto"/></p>

<p>The neat trick I'm trying is making this pattern a little darker with each row to create a shadow-type effect that gives the illusion of depth or something like that. I don't really know the right artistic terms to use. I accomplished that by switching palettes after each row.</p>

<p>Since I'm filling up the palettes I also created a spreadsheet to track what I'm using each entry for. I can still add 10 colors for the next iteration of this demo.</p>

<p><img src="palettes.png" alt="Palette map for this demo" class="img-fluid d-block mx-auto"/></p>

<p>You can also infer that I have some idea of what the first two NPCs will look like from this. Anyway, on to the code...</p>

<div class="well">
<p>DrawLowPlaneScenery:</p>
<p>&nbsp;; draw shelves with merchandise</p>
<p>&nbsp;move.w #$0065,d0 ; store base tile ID in d0</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_B,d4 ; initial address offset</p>
<p>&nbsp;; start drawing the counter at row 1, column 0 = 128</p>
<p>&nbsp;; 128 = 0080 = 0000 0000 1000 0000</p>
<p>&nbsp;add.l #$00800000,d4 ; initial address offset</p>
<p>&nbsp;move.l d4,(VDP_CONTROL) ; initial drawing location</p>
<p>&nbsp;move.w #$0002,d1 ; 3 rows</p>
<p>DrawLowPlaneSceneryRowLoop:</p>
<p>&nbsp;move.w #$0014,d2 ; 64 columns per row / 3 tiles in pattern</p>
<p>DrawLowPlaneSceneryColLoop:</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy the pattern to VPD</p>
<p>&nbsp;add.w #$0001,d0 ; move to the 2nd tile in the pattern</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy the pattern to VPD</p>
<p>&nbsp;add.w #$0001,d0 ; move to the 3rd tile in the pattern</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy the pattern to VPD</p>
<p>&nbsp;sub.w #$0002,d0 ; move back to the first tile in the pattern</p>
<p>&nbsp;dbra d2,DrawLowPlaneSceneryColLoop ; loop to next tile</p>
<p>&nbsp;add.w #$2000,d0 ; increment the palette</p>
<p>&nbsp;dbra d1,DrawLowPlaneSceneryRowLoop ; loop to next tile</p>
</div>

<p>So now we have some shelves that don't look half-bad.</p>

<p><img src="shelves.png" alt="Store shelves" class="img-fluid d-block mx-auto"/></p>

<p>Next up let's add a frame around the store with some transparent windows in front. Here's the tileset for that:</p>

<p><img src="tileset-frame.png" alt="Tileset for frame" class="img-fluid d-block mx-auto"/></p>

<p>The code to create it draws out the border first then the front. The front part is done through the <a href="https://huguesjohnson.com/programming/genesis/collision-detection/">DrawTileset subroutine created previously</a>, the border is done brute-force.</p>

<div class="well">
<p>DrawFrame:</p>
<p>&nbsp;move.w #$8068,d0 ; store base tile ID in d0</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d4 ; initial address offset</p>
<p>&nbsp;move.l d4,(VDP_CONTROL) ; initial drawing location</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy the first tile to VPD</p>
<p>&nbsp;; draw the top row</p>
<p>&nbsp;move.w #$8069,d0 ; store tile ID in d0</p>
<p>&nbsp;move.w #$0025,d2 ; 38 columns to draw</p>
<p>DrawFrameTopLoop:</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy tile to VPD</p>
<p>&nbsp;dbra d2,DrawFrameTopLoop ; loop to next tile</p>
<p>&nbsp;move.w #$806A,d0 ; store tile ID in d0</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy last tile to VPD</p>
<p>&nbsp;; setup for drawing the side</p>
<p>&nbsp;move.w #$806B,d0 ; store tile ID of side in d0</p>
<p>&nbsp;move.w #$001A,d2 ; 27 rows to draw</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d4 ; initial address offset</p>
<p>&nbsp;add.l #$00800000,d4 ; increment drawing location to move to next row</p>
<p>DrawFrameSideLoop:</p>
<p>&nbsp;move.l d4,(VDP_CONTROL) ; update drawing location</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy tile to VPD</p>
<p>&nbsp;add.l #$004E0000,d4 ; column 78 (78x4=312px)</p>
<p>&nbsp;move.l d4,(VDP_CONTROL) ; update drawing location</p>
<p>&nbsp;move.w d0,(VDP_DATA) ; copy tile to VPD</p>
<p>&nbsp;add.l #$00320000,d4 ; increment drawing location</p>
<p>&nbsp;dbra d2,DrawFrameSideLoop ; loop to next tile</p>
<p>DrawStoreFront:</p>
<p>&nbsp;; setup call to DrawTileset</p>
<p>&nbsp;lea PatternStoreFrontStart,a1 ; store the high starting address in a2</p>
<p>&nbsp;; tile 0 for the counter pattern should be at index 6Ch</p>
<p>&nbsp;move.w #$806C,d0 ; store base tile ID in d0</p>
<p>&nbsp;move.w #$0003,d1 ; 4 rows in the pattern</p>
<p>&nbsp;move.w #$0027,d2 ; 40 columns in the pattern</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d3 ; initial address offset</p>
<p>&nbsp;; draw the high plane at row 28 (3584), column 0 (0px) = 3584 = E00</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d3 ; initial address offset</p>
<p>&nbsp;add.l #$0E000000,d3 ; initial address offset</p>
<p>&nbsp;bsr.w DrawTileset ; branch to DrawTileset subroutine</p>

</div>

<p>This store front doesn't look half-bad either, some window signs would be nice though.</p>

<p><img src="front.png" alt="Store front" class="img-fluid d-block mx-auto"/></p>

<p>The counter has also been redesigned a little but the tileset didn't change all that much. I made it a good deal larger now that our store has a more space. There are still separate sections to add the high and low tiles.</p>

<div class="well">
<p>DrawCounter:</p>
<p>&nbsp;; setup call to DrawTileset for low tiles</p>
<p>&nbsp;lea PatternCounterLowStart,a1 ; store the low starting address in a1</p>
<p>&nbsp;; tile 0 for the counter pattern should be at index 81h, palette 01, low</p>
<p>&nbsp;; 0010 0000 1000 0001 = 2081</p>
<p>&nbsp;move.w #$2081,d0 ; store base tile ID in d0</p>
<p>&nbsp;move.w #$0003,d1 ; 4 rows in the pattern</p>
<p>&nbsp;move.w #$000D,d2 ; 15 columns in the pattern</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d3 ; initial address offset</p>
<p>&nbsp;; start drawing at row 10, column 28 (112px) = 1280+28 = 51C</p>
<p>&nbsp;add.l #$051C0000,d3 ; initial address offset</p>
<p>&nbsp;bsr.w DrawTileset ; branch to DrawTileset subroutine</p>
<p>&nbsp;; setup call to DrawTileset for high tiles</p>
<p>&nbsp;lea PatternCounterHighStart,a1 ; store the high starting address in a1</p>
<p>&nbsp;; tile 0 for the counter pattern should be at index 91h, palette 01, high</p>
<p>&nbsp;move.w #$A091,d0 ; store base tile ID in d0</p>
<p>&nbsp;move.w #$0006,d1 ; 7 rows in the pattern</p>
<p>&nbsp;move.w #$000D,d2 ; 14 columns in the pattern</p>
<p>&nbsp;move.l #VDP_VRAM_WRITE_A,d3 ; initial address offset</p>
<p>&nbsp;; start drawing at row 3, column 28 (112px) = 394+28 = 19C</p>
<p>&nbsp;add.l #$019C0000,d3 ; initial address offset</p>
<p>&nbsp;bsr.w DrawTileset ; branch to DrawTileset subroutine</p>

</div>

<p>Hmmm... maybe this is too large now, or maybe it will be fine whenever I add a cash register to it.</p>

<p><img src="counter.png" alt="Store counter" class="img-fluid d-block mx-auto"/></p>

<p>The store looks better but is still kinda bland, I should add some racks or displays in the store too. Maybe I'll save that for next time.</p>

<p>It seems more likely though that my next iteration will include creating some kind of data structure to store all the layers of room rather than brute-force creating them like I'm doing now. There are tons of small things to fix too like some clipping and timing issues.</p>

<p>I also want to redesign the sprite since it looks way too much like a Phantasy Star II sprite.</p>

<p>So what will I tackle next time? One of these ideas or something completely different? Check back in some arbitrary time period to find out...</p>

<p class="lead">Download</p>

<p><a href="https://github.com/huguesjohnson/RetailClerk89">Download the latest source code on GitHub</a></p>


	<br>	
	<div class="row">
		<div class="col">
			<a class="float-left" href="https://huguesjohnson.com/programming/genesis/collision-detection/">&lt;- Part 5: Collision Detection</a>
		</div>
		<div class="col">
			&nbsp;
			<a class="float-right" href="https://huguesjohnson.com/programming/genesis/npcs/">Part 7: NPC Sprites -&gt;</a>
		</div>
	</div>
	<br>

<hr>

<p class="lead blog-description">Related</p>

<div class="row container">

<div class="col-sm"><a href="https://huguesjohnson.com/rc89/"><p><img class="img-thumbnail" src="https://huguesjohnson.com/images/related/rc89.png" alt="Retail Clerk '89"></p><p>Retail Clerk '89</p></a></div>

<div class="col-sm"><a href="https://huguesjohnson.com/programming/genesis/scene-npcs/"><p><img class="img-thumbnail" src="https://huguesjohnson.com/images/related/genesisscenenpcs.png" alt="Sega Genesis Programming Part 12: Scenes and NPCs"></p><p>Sega Genesis Programming Part 12: Scenes &amp; NPCs</p></a></div>

<div class="col-sm"><a href="https://huguesjohnson.com/programming/genesis/palette-tile-generation/"><p><img class="img-thumbnail" src="https://huguesjohnson.com/images/related/genesispalettetilegen.png" alt="Sega Genesis Programming Part 20: Palette and Tile Generation"></p><p>Sega Genesis Programming Part 20: Palette and Tile Generation</p></a></div>

</div>

<br clear="all"/>



<!-- begin share -->
<!-- end share -->

<!-- begin support -->

<!-- end support -->

<hr>

<!-- begin footer -->
      <footer>
		<p>All source code and software on this site is distributed under <a href="https://opensource.org/licenses/MIT">The MIT License</a> (copyright 2000-2020 Hugues Johnson) unless otherwise noted. </p>
		<p>All other content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a> unless otherwise noted.</p>
		<p>All opinions on this site reflect my personal views and do not represent views of my current, or any former, employer.</p>
		<p>Site theme is based on <a href="https://getbootstrap.com">Bootstrap</a> licensed under <a href="https://github.com/twbs/bootstrap/blob/master/LICENSE">The MIT License</a>. Site font is Ubuntu licensed under <a href="https://font.ubuntu.com/ufl/ubuntu-font-licence-1.0.txt">Ubuntu Font License</a>. Navigation logo font is Audiowide licensed under <a href="https://scripts.sil.org/OFL">Open Font License</a>.</p>
		<p>This site does not contain advertisements or sponsored content. I am not remotely interested in either so don't ask.</p>
		<p>Privacy policy: I don't care even a little about who visits this site and make no attempt to track usage. The content delivery network I use happens to collect user agent and IP address but I never look at them. This site does not use cookies.</p>
      </footer>
<!-- end footer -->


    </div><!-- /.container -->


<!-- begin page end -->
<!-- end page end -->

</body>

</html>
