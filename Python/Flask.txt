Flask
25-Jul-2024

Flask_Web_Development_Developing
git clone https://github.com/miguelgrinberg/flasky.git


PART-I
Chp.1

Chp.2
Pg.7
All Flask applications must create an application instance
web server passes all requests rec'd from clients to application instance
[object] using protocol WSGI Web Server Gateway Interface
application instance is an object of class Flask

Pg.8
Decorator
register functons as handlers for an event

Pg.9
Routes
dynamic part
/user/<name>
/user/<int:id>


Pg.12
Request object

Flask context
temp make certain objects globally accessible

Pg.13
Thread
smallest sequence of instructions managed independently
Multithreaded web servers start a pool of threads and select a thread from the pol tohandle each incoming request


Two contexts
Application context	AC
Request context	RC

current_app	AC	application instance
g		AC	object application use for temp storage during request
request	RC	request object - encap contents of HTTP request sent by client
session	RC	user session - dict application use to store values across requests


Pg.14
from hello import app
app.url_map
Map([<Rule '/' (OPTIONS, HEAD, GET) -> index>,
 <Rule '/static/<filename>' (OPTIONS, HEAD, GET) -> static>,
 <Rule '/user/<name>' (OPTIONS, HEAD, GET) -> user>])

GET = request method


Pg.14
request hooks
e.g.
share data btwn request hook + view func = g context global
g.user

Pg.15
Response
HTTP Response = status code

@app.route('/')
def index():
return '<h1>Bad Request</h1>', 400

or
return Response object	
make_response()
example Pg.16

redirect()
abort(404)


Pg.18
Flask script
python hello.py runserver --help



Chp.3
Pg.21
Rendering
process replace variables w/ actual values + returns final response

Jinja2
template engine used by Flask

Pg.26
Bootstrap
Flask extension

Pg.33
Localization
server needs uniform time units independent of user location
UTC


Chp.4
Pg.37
CSRF
Cross-Site Request Forgery (CSRF) Protection
flask-wtf

CSRF
Cross-Site Request Forgergy 
attack
occurs when a malicious website sends requests to a different website
on which the victim is logged in

encrypted token
used to verify authenticity of [POST] requests w/ form data
e.g.
app = Flask(__name__)
app.config['SECRET_KEY'] = 'hard to guess string'

Pg.38
SECRET_KEY
general-purpose encryption key used by Flask

IMPORTANT
security: secret key should be stored in an environment variable
[Chp.7]

Pg.44
IMPORTANT
never leave a POST request as last request sent by the browser
send a redirect instead of a normal response
now last request = GET
Post/Redirect/Get pattern

Store any data for redirect in user session [request context]
private storage available to each connected client

Pg.45
session dictionary
user sessions are stored in client-side cookies that are 
cryptographically signed using configured SECRET_KEY

any tampering with the cookie content renders signature invalid
thus invalidating the session


Chp.5
Pg.49
NoSQL
document-orientated + key/value DBs

Pg.50
collections	instead of tables
documents	instead of rows

Denormalization
reduce number of tables at expense of data duplication

Pg.51
SQLAlchemy
higher level Python objecgs instead of DB entities
e.g. tables, documents or query languages

Abstraction layers
ORM	Object Relational Mappers
ODM	Object Document Mappers

transparen conversion high-level OO ops into low-level DB instructions

Pg.52
SQLAlchmeny ORM
Postres, MySQL, SQLite

Flask integration
Flask-SQLAlchemy: the Flask extension wrapper for SQLAlchemy

pip install flask-sqlalchemy

Pg.53
URLs
Postgres postgresql://username:password@hostname/database
SQLALCHEMY_DATABASE_URI

SQLALCHEMY_COMMIT_ON_TEARDOWN
True
auto commit DB changes end-of-each request

Pg.54
model
persistent entities in application
Python class w/ attributes match DB table columns

IMPORTANT
convention = use plurals for table names
SQLAlchemy column types

Pg.55
SQLAlchemy column option

Flask-SQLAlchemy requires all models to define a primary key column
which is normally named id

Pg.56
relationshops

Pg.57
SQLAlchemy relationship options
one-to-one	uselist=False
many-to-many	association table

Pg.58
Python shell
python hello.py shell

Pg.59
DB session
[transactions]

changes to DB managed thru DB session
Flask-SQLAlchemy provides as db.session
objects to be written to DB must be added to DB sesson

db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david])

write objects to DB
db.session.commit()

db.session.rollback()
is called, any objects that were added to the database session are
restored to the state they have in the database

Pg.60
Add row
db.session.add(admin_role)

Delete row
db.session.delete(mod_role)

Query row
Role.query.all()
filters
User.query.filter_by(role=user_role).all()

SQL query
str(User.query.filter_by(role=user_role))
'SELECT users.id AS users_id, users.username AS users_username,
users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id'

Pg.61
user_role = Role.query.filter_by(name='User').first()

Common SQLAlchemy query filters

all()
cause query to execute
common SQLAlchemy query executors

Pg.62
lazy = 'dynamic' argument to request that the query is not
users = db.relationship('User', backref='role', lazy='dynamic')

Pg.63
Integration with the Python Shell
make_context callback function

Pg.64
Database Migrations with Flask-Migrate
database migration framework
changes to database schema

Alembic
book uses flask-migrate

Pg.65
Alembic
migration script
upgrade()		DB changes part of migration
downgrade()		removes them

alembic
revision + migrate commands
e.g.
python hello.py db migrate -m "initial migration"
vs. our example
alembic revision --autogenerate -m "Create initial tables"

Pg.66
Upgrading the Database
db upgrade
vs. our example
alembic upgrade head


CHp.6	Email
pip install flask-mail

Chp.7 	Application structure
Pg.75
similar project structure
app		Flass application
migrations	DB migration scripts
tests		unit / integration tests
.venv		virtual environment

requirements.txt	package dependencies
config.py		config settings
manage.py		app tasks mgt

Pg.76
config.py

import os
basedir = os.path.abspath(os.path.dirname(__file__))
class Config:
SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string'

Pg.77
Using an Application Factory

delay creation of application into a factory function

create_app()
application factory

Pg.78
Pg.79
def create_app() -> Flask:
	app = Flask(__name__)
	# ...
	return app

factory function returns the created application instance
except
routes and custom error page handlers... next


Implementing Application Functionality in a Blueprint
app created at runtime = problem
app.route decorator begins to exist only after create_app() is invoked,
which is too late

Solution: blueprints	["delayed" routes]

blueprint
similar to application in that it can also define routes
difference = routes associated with blueprint = dormant state
until is registered with an applcation
at whcih point the routes become part of it [the Flask application]

Blueprint creation
from flask import Blueprint

Pg.80
Blueprints are created by instantiating an object Blueprint
ctor
Blueprint name and module	package where blueprint located

usually module [2nd arg]	__name__

routes
error handlers

bluieprint registered w/ application	[inside create_app()] factory function

NB: not used in our app
app_errorhandler 
app.register_blueprint(blueprint)

but does have
@blueprint.route("/")
@blueprint.errorhandler()

Pg.81
route decorator comes from the blueprint

endpoint name of the route
application based routes defaults name for view function
but
blueprints: Flask applies a namespace to all the endpoints
coming from a blueprint so multple blueprints can define view functions
w/ the same endpoint names w/o collisions

NB: could not find
url_for()

Pg.82
manage.py
script creates Flask application
configuration defined
Flask-Script
Flask-Migrate initialized

NB:
whole shebang
#!/usr/bin/env python

execute script
./manage.py

instead of
python manage.py

Requirements file
Applications must include requirements.txt to record all package dependencies
with exact version numbers

pip freeze >requirements.txt
pip install -r requirements.txt

Pg.83-84
Unit Tests
import unittest

def setUp(self):
self.app = create_app('testing')
self.app_context = self.app.app_context()
self.app_context.push()
db.create_all()

setup()
creates an application configured for testing and activates its context
creates a new database that tests can use


def tearDown(self):
db.session.remove()
db.drop_all()
self.app_context.pop()
tearDown()
database and the application context are removed

Pg.85
When working with Flask-Migrate to keep track of migrations, da‚Äê
tabase tables can be created or upgraded to the latest revision with a single command:
(venv) $ python manage.py db upgrade
Database Setup
