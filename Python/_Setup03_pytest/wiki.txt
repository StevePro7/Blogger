<span style="font-family:verdana;font-size:85%;">

In 2020, we checked out <a href="https://steveproxna.blogspot.com/2020/07/python-setup-cheat-sheet.html">Python Setup Cheat Sheet</a> as an interpreted high-level programming language with all code samples' unit tests using unittest package TestCase class.  However, since then we have learned that <a href="https://pytest-with-eric.com">pytest</a> allows writing shorter more readable tests with less boilerplate.  Plus we would like to include mocks!!  
<br />
<!--
<a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5SeutLv2xN_orl-llnhD8H58gAtNhBFoIXsyAywK3-tcb0Ov_I4igsZhlk-1QHT2eMPOzY6nn8vQMx_HNHamjKR9eRKRshTajA5xZ-Jekpr-FIAMGht4ayQeF0Vd_2WYAXfuGGQh6winK76XYjsvvYEC2JIA5F2_iuXlobGn7PzMwq2LMPjUjUExW7nc/s2360/PythonPytest.jpg"><img alt="" border="0" width="98%" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi5SeutLv2xN_orl-llnhD8H58gAtNhBFoIXsyAywK3-tcb0Ov_I4igsZhlk-1QHT2eMPOzY6nn8vQMx_HNHamjKR9eRKRshTajA5xZ-Jekpr-FIAMGht4ayQeF0Vd_2WYAXfuGGQh6winK76XYjsvvYEC2JIA5F2_iuXlobGn7PzMwq2LMPjUjUExW7nc/s600/PythonPytest.jpg"/></a>
-->
<br />
Let's check it out!
<br /><br />

<u>Frameworks</u><br />
When developing code in Python there are typically five Top Python Testing <a href="https://pytest-with-eric.com/comparisons/python-testing-frameworks">Frameworks</a> that are favorable:
<br />
<!--
<table width="99%" border="1">
<tr><td>&nbsp;<b>NAME</b>&nbsp;</td><td>&nbsp;<b>MONIKER </b>&nbsp;</td><td>&nbsp;<b>DESCRIPTION</b></td></tr>
<tr><td>&nbsp;unittest&nbsp;</td><td>&nbsp;PyUnit&nbsp;</td><td>&nbsp;The default Python testing framework built-in with the Python Standard Library</td></tr>
<tr><td>&nbsp;pytest&nbsp;</td><td>&nbsp;Pytest&nbsp;</td><td>&nbsp;Popular testing frameworks known for simplicity, flexibility + powerful features</td></tr>
<tr><td>&nbsp;noseTest&nbsp;</td><td>&nbsp;Nose2&nbsp;</td><td>&nbsp;Enhanced unittest version offering additional plugins to support test execution</td></tr>
<tr><td>&nbsp;DocTest&nbsp;</td><td>&nbsp;DocTest&nbsp;</td><td>&nbsp;Python Standard Library module generates tests within source code DocString</td></tr>
<tr><td>&nbsp;Robot&nbsp;</td><td>&nbsp;Robot&nbsp;</td><td>&nbsp;Acceptance testing keyword-driven module that simplifies testcase automation</td></tr>
</table>
-->
<br />
Here are some reasons why <a href="https://docs.pytest.org/en/stable">pytest</a> currently seems to be the most popular Python unit test framework out:
<br />
<!--
<table width="99%" border="1">
<tr>
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;1. Simple and Readable Syntax
&nbsp;&nbsp;   You write plain Python functions instead of creating large verbose classes.
&nbsp;&nbsp;   Assertions use plain assert statements which provide more detailed output.
</pre>
</td>
</tr>
<tr>  
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;2. Rich Plugin Ecosystem
&nbsp;&nbsp;   Plugins like pytest-mock, pytest-asyncio, pytest-cov, and more.
&nbsp;&nbsp;   Easy to extend pytest plugins or write your own custom plugins.
</pre>
</td>
</tr>
<tr>  
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;3. Powerful Fixtures
&nbsp;&nbsp;   Allows for clean and re-usable setup and teardown using fixtures.
&nbsp;&nbsp;   Supports various test level scopes, autouse, and parametrization.
</pre>
</td>
</tr>
<tr>  
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;4. Test Discovery
&nbsp;&nbsp;   Automatically disovers tests in files named test_*.py.
&nbsp;&nbsp;   No need to manually register tests or use loader classes.
</pre>
</td>
</tr>
<tr>  
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;5. Great Reporting
&nbsp;&nbsp;   Colored output, diffs for failing assertions, and optional verbosity.
&nbsp;&nbsp;   Integrates easily with tools like coverage, tox, and CI/CD systems.
</pre>
</td>
</tr>
<tr>  
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;6. Supports Complex Testing Needs
&nbsp;&nbsp;   Parameterized tests (@pytest.mark.parametrize)
&nbsp;&nbsp;   parallel test execution (pytest-xdist) + hooks
</pre>
</td>
</tr>
</table>
-->
<br />
  
<u>Setup</u><br />
Depending on your stack here is some great documentation to setup pytest on <a href="https://pytest-with-eric.com/integrations/pytest-pycharm-integration">PyCharm</a>, <a href="https://pytest-with-eric.com/introduction/how-to-run-pytest-in-vscode">VS Code</a> or <a href="https://pytest-with-eric.com/getting-started/poetry-run-pytest">Poetry</a>.
<br /><br />

<u>Configuration</u><br />
In pytest, <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-ini">pytest.ini</a> is the main configuration file used to customize and control pytest behavior across the unit test suite.  pytest.ini hosts pytest options, test paths, plugin settings and markers to attach to the test functions to categorize, filter or modify their behavior.  Here is a sample pytest.ini configuration file as base: 
<br />
<!--
<table width="99%" border="1">
<tr><td>
<pre style="font-size: 12px;">
&nbsp;&nbsp;[pytest]  
&nbsp;&nbsp;addopts = -ra -q
&nbsp;&nbsp;testpaths = tests
&nbsp;&nbsp;markers =
&nbsp;&nbsp;    slow: marks tests as slow (deselect with '-m "not slow"')
&nbsp;&nbsp;    db: marks tests requiring database
</pre>
</td></tr>
</table>
-->
<br />
  
<u>Fixtures</u><br />
<a href="https://pytest-with-eric.com/fixtures/pytest-fixtures">Fixtures</a> are methods in pytest that provide fixed baseline for tests to run.  Fixtures can be used to <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-setup-teardown/#What-is-Setup-and-Teardown">setup</a> all preconditions for tests, provide data, or perform <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-setup-teardown/#What-is-Setup-and-Teardown">teardown</a> after tests finished via @pytest.fixture decorator.
<br /><br /> 
<i>Scope</i><br />
Fixtures have scope: Function, Class, Module + Session which define how long fixture available during test:
<br />
<!--
<table width="99%" border="1">
<tr><td>&nbsp;<b>SCOPE</b></td><td>&nbsp;<b>DESCRIPTION</b></td></tr>
<tr><td>&nbsp;Function</td><td>&nbsp;Fixture created once per test function and destroyed at end of test function</td></tr>
<tr><td>&nbsp;Class</td><td>&nbsp;Fixture created once per test class and destroyed at the end of test class</td></tr>
<tr><td>&nbsp;Module</td><td>&nbsp;Fixture created once per test module and destroyed at end of test module</td></tr>
<tr><td>&nbsp;Session</td><td>&nbsp;Fixture created once per test session and destroyed at end of test session</td></tr>
</table>
-->
<br />
<i>conftest</i><br />
In pytest, <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-conftest">conftest.py</a> file is used to share fixtures across multiple tests.  All the fixtures in conftest.py will be automagically detected without needing to import.  conftest: typically scoped at test root directory structure.
<br /><br />
<i>Dependencies</i><br />
Dependency Injection: when fixtures are requested by other fixtures although this adds complexity to tests!
<br /><br />
<i>autouse</i><br />
Simple trick to avoid defining fixture in each test: use the <b><a href="https://pytest-with-eric.com/fixtures/pytest-fixture-autouse">autouse</a>=True</b> flag to apply fixture to all tests.
<br /><br />
<i>yield</i><br />
When you use <a href="https://pytest-with-eric.com/fixtures/pytest-fixtures/#Yield-vs-Return-in-Fixtures">yield</a> in fixture function setup code executes before yield and teardown executes after yield: 
<br />
<!--  
<table width="99%" border="1">
<tr><td>
<pre style="font-size: 12px;">
&nbsp;&nbsp;import pytest  
&nbsp;&nbsp;@pytest.fixture
&nbsp;&nbsp;def my_fixture(): 
&nbsp;&nbsp;    # setup code
&nbsp;&nbsp;    yield "fixture value"
&nbsp;&nbsp;    # teardown code
</pre>
</td></tr>
</table>
-->
<br />
<i>Arguments</i><br />
Use pytest fixtures with <a href="https://pytest-with-eric.com/fixtures/pytest-fixture-with-arguments">arguments</a> to write reusable fixtures that can easily share across tests also known as Parameterized fixtures using <i>@pytest.fixture(params=[0, 1, 2])</i> syntax.  Note: these fixtures should not be confused with the <i>@pytest.mark.parametrize</i> <a href="https://pytest-with-eric.com/introduction/pytest-parameterized-tests/#What-Are-Pytest-Parameters">decorator</a> which can be used to specify inputs and outputs!
<br /><br />
<i>Factories</i><br />
<a href="https://pytest-with-eric.com/fixtures/pytest-fixture-with-arguments/#Factories-As-Fixtures">Factories</a>, in the context of pytest fixtures, are functions that are used to create and return instances of objects that are needed to generate test data or objects with specific configuration in reusuable manner:
<br />
<!--
<table width="99%" border="1">
<tr>
<td>&nbsp;<b>conftest.py</b></td>
<td>&nbsp;<b>unittest.py</b></td>
</tr>
<tr>
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;@pytest.fixture
&nbsp;def user_creds(): 
&nbsp;  def _user_creds(name: str, email: str):
&nbsp;    return {"name": name, "email": email}  
&nbsp;  return _user_creds
</pre>
</td>
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;def test_user_creds(user_creds):
&nbsp;  assert user_creds("John", "x@abc.com")=={  
&nbsp;    "name": "John",  
&nbsp;    "email": "x@abc.com",
&nbsp;  }
</pre>
</td>
</tr>
</table>
-->  
<br />
Best <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-organize-tests">practices</a> for organizing tests include: Organizing Tests by Testing <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-organize-tests/#Best-Practice-1-%E2%80%94-Organizing-Tests-by-Testing-Pyramid">Pyramid</a>, Structure Should <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-organize-tests/#Best-Practice-2-Test-Structure-Should-Mirror-Application-Code">Mirror</a> Application Code, <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-organize-tests/#Best-Practice-3-%E2%80%94-How-to-Group-or-Organize-Fixtures">Group</a> or Organize Fixtures and Organize Tests <a href="https://pytest-with-eric.com/pytest-best-practices/pytest-organize-tests/#Tests-Outside-Application-Code">Outside</a> Application Code for scalability.
<br /><br />
  
<u>Mocking</u><br />
<a href="https://pytest-with-eric.com/mocking/pytest-mocking">Mocking</a> is technique that allows you to isolate pieces of code being tested from its dependencies so the test can focus on the code under test in isolation.  The <a href="https://docs.python.org/3/library/unittest.mock.html">unittest.mock</a> package offers Mock and MagicMock objects:
<br /><br />
<i><a href="https://docs.python.org/3/library/unittest.mock.html#the-mock-class">Mock</a></i><br />
A mock object simulates the behavior of the object it replaces by creating attributes and methods on-the-fly.
<br /><br />
<i><a href="https://docs.python.org/3/library/unittest.mock.html#magic-mock">MagicMock</a></i><br />
Subclass of Mock with default implementations for most magic methods (__len__, __getitem__, etc.).  Useful when mocking objects that interact with Python's dunder methods that enable custom behaviors for common operations.
<br /><br />
  
<u>Patching</u><br />
<a href="https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#Mock-and-Patch-%E2%80%94-A-Brief-Recap">Patching</a> is technique that temporarily replaces real objects in code with mock objects during test execution.  <a href="https://pytest-with-eric.com/mocking/mocking-vs-patching/#Understanding-Patching-How-It-Works">Patching</a> helps ensure external systems do not affect test outcomes thus tests are consistent and repeatable.
<br /><br />
IMPORTANT - Mocks are <b>NOT</b> stubs!<br />
When we combine <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch">@patch</a> decorator with <i>return_value</i> or <i>side_effect</i> it is a stub but from the <a href="https://docs.python.org/3/library/unittest.mock.html">mock</a> package!
<br />
<table width="99%" border="1">
<tr><td>&nbsp;<b>METHOD</b></td><td>&nbsp;<b>DESCRIPTION</b></td></tr>
<tr><td>&nbsp;<a href="https://pytest-with-eric.com/mocking/pytest-mock-multiple-return-values/#Single-Return-Value-Mocking">return_value</a></td><td>&nbsp;Specify the single value of Mock object to be returned when method called</td></tr>
<tr><td>&nbsp;<a href="https://pytest-with-eric.com/mocking/pytest-mock-multiple-return-values/#Multiple-Return-Values-with-%E2%80%98side-effect%E2%80%99">side_effect</a></td><td>&nbsp;Specify multiple values of Mock object to be returned when method called</td></tr>
</table>
<br />

<u>Difference</u><br />
In pytest, Mock and patch are both <a href="https://pytest-with-eric.com/mocking/python-magicmock-raise-exception/#What-is-the-Difference-Between-Mock-and-Patch">tools</a> for simulating or replacing parts of your code during testing.  Mock creates mock objects while patch temporarily replaces real objects with mocks during tests to isolate code:
<br />
<!--
<table width="99%" border="1">
<tr>
<td>&nbsp;<b>Mock</b></td>
<td>&nbsp;<b>patch</b></td>
</tr>
<tr>
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;from unittest.mock import Mock  
&nbsp;&nbsp;
&nbsp;&nbsp;mock_obj = Mock()
&nbsp;&nbsp;mock_obj.some_method.return_value = 42 
&nbsp;&nbsp;result = mock_obj.some_method()  
&nbsp;&nbsp;assert result == 42
</pre>
</td>
<td valign="top">
<pre style="font-size: 12px;">
&nbsp;&nbsp;from unittest.mock import patch
&nbsp;&nbsp;
&nbsp;&nbsp;def external_function(): 
&nbsp;&nbsp;    pass
&nbsp;&nbsp;
&nbsp;&nbsp;@patch('module_name.external_function')  
&nbsp;&nbsp;def test_function(mock_external): 
&nbsp;&nbsp;    mock_external.return_value = "Mock data"
&nbsp;&nbsp;    result = external_function() 
&nbsp;&nbsp;    assert result == "Mock data"
</pre>
</td>
</tr>
</table>
-->
<br />
  
IMPORTANT<br />
When creating mocks it is critical to ensure mock objects accurately reflect objects they are replacing.  Thus, it is best practice to use <b><a href="https://pytest-with-eric.com/mocking/pytest-common-mocking-problems/#Mocks-Fail-To-Respect-Method-Signature">autospec</a>=True</b> to ensure mock objects respect function signatures being replaced!
<br /><br />
<u>Assertions</u><br />
For completeness, here is list of <a href="https://pytest-with-eric.com/mocking/pytest-mock-assert-called/#Pytest-Mock-Assert-Call-The-Key-Concepts">assertion</a> methods to verify method on mock object was called during tests:
<br />
<!--
<table width="99%" border="1">
<tr><td>&nbsp;<b>METHOD</b></td><td>&nbsp;<b>DESCRIPTION</b></td></tr>
<tr><td>&nbsp;assert_called</td><td>&nbsp;verify specific method on mock object has been called during a test</td></tr>
<tr><td>&nbsp;assert_called_once</td><td>&nbsp;verify specific method on mock object has been called only one time</td></tr>
<tr><td>&nbsp;assert_called_once_with</td><td>&nbsp;verify specific method on mock object called once with specific args</td></tr>
<tr><td>&nbsp;assert_called_with</td><td>&nbsp;verify every time method on mock object called with fixed arguments</td></tr>
<tr><td>&nbsp;assert_not_called</td><td>&nbsp;verify specific method on mock object was not called during the test</td></tr>
<tr><td>&nbsp;assert_has_calls</td><td>&nbsp;verify the order in which specific method on mock object was called</td></tr>
<tr><td>&nbsp;assert_any_call</td><td>&nbsp;verify specific method on mock object has been called at least once</td></tr>
</table>
-->
<br />
  
</span>